{"ast":null,"code":"/*eslint-disable no-cond-assign */\nmodule.exports = parse;\nmodule.exports.parse = parse;\nmodule.exports.stringify = stringify;\nvar numberRegexp = /[-+]?([0-9]*\\.[0-9]+|[0-9]+)([eE][-+]?[0-9]+)?/; // Matches sequences like '100 100' or '100 100 100'.\n\nvar tuples = new RegExp('^' + numberRegexp.source + '(\\\\s' + numberRegexp.source + '){1,}');\n/*\n * Parse WKT and return GeoJSON.\n *\n * @param {string} _ A WKT geometry\n * @return {?Object} A GeoJSON geometry object\n */\n\nfunction parse(input) {\n  var parts = input.split(';');\n\n  var _ = parts.pop();\n\n  var srid = (parts.shift() || '').split('=').pop();\n  var i = 0;\n\n  function $(re) {\n    var match = _.substring(i).match(re);\n\n    if (!match) return null;else {\n      i += match[0].length;\n      return match[0];\n    }\n  }\n\n  function crs(obj) {\n    if (obj && srid.match(/\\d+/)) {\n      obj.crs = {\n        type: 'name',\n        properties: {\n          name: 'urn:ogc:def:crs:EPSG::' + srid\n        }\n      };\n    }\n\n    return obj;\n  }\n\n  function white() {\n    $(/^\\s*/);\n  }\n\n  function multicoords() {\n    white();\n    var depth = 0;\n    var rings = [];\n    var stack = [rings];\n    var pointer = rings;\n    var elem;\n\n    while (elem = $(/^(\\()/) || $(/^(\\))/) || $(/^(,)/) || $(tuples)) {\n      if (elem === '(') {\n        stack.push(pointer);\n        pointer = [];\n        stack[stack.length - 1].push(pointer);\n        depth++;\n      } else if (elem === ')') {\n        // For the case: Polygon(), ...\n        if (pointer.length === 0) return null;\n        pointer = stack.pop(); // the stack was empty, input was malformed\n\n        if (!pointer) return null;\n        depth--;\n        if (depth === 0) break;\n      } else if (elem === ',') {\n        pointer = [];\n        stack[stack.length - 1].push(pointer);\n      } else if (!elem.split(/\\s/g).some(isNaN)) {\n        Array.prototype.push.apply(pointer, elem.split(/\\s/g).map(parseFloat));\n      } else {\n        return null;\n      }\n\n      white();\n    }\n\n    if (depth !== 0) return null;\n    return rings;\n  }\n\n  function coords() {\n    var list = [];\n    var item;\n    var pt;\n\n    while (pt = $(tuples) || $(/^(,)/)) {\n      if (pt === ',') {\n        list.push(item);\n        item = [];\n      } else if (!pt.split(/\\s/g).some(isNaN)) {\n        if (!item) item = [];\n        Array.prototype.push.apply(item, pt.split(/\\s/g).map(parseFloat));\n      }\n\n      white();\n    }\n\n    if (item) list.push(item);else return null;\n    return list.length ? list : null;\n  }\n\n  function point() {\n    if (!$(/^(point(\\sz)?)/i)) return null;\n    white();\n    if (!$(/^(\\()/)) return null;\n    var c = coords();\n    if (!c) return null;\n    white();\n    if (!$(/^(\\))/)) return null;\n    return {\n      type: 'Point',\n      coordinates: c[0]\n    };\n  }\n\n  function multipoint() {\n    if (!$(/^(multipoint)/i)) return null;\n    white();\n\n    var newCoordsFormat = _.substring(_.indexOf('(') + 1, _.length - 1).replace(/\\(/g, '').replace(/\\)/g, '');\n\n    _ = 'MULTIPOINT (' + newCoordsFormat + ')';\n    var c = multicoords();\n    if (!c) return null;\n    white();\n    return {\n      type: 'MultiPoint',\n      coordinates: c\n    };\n  }\n\n  function multilinestring() {\n    if (!$(/^(multilinestring)/i)) return null;\n    white();\n    var c = multicoords();\n    if (!c) return null;\n    white();\n    return {\n      type: 'MultiLineString',\n      coordinates: c\n    };\n  }\n\n  function linestring() {\n    if (!$(/^(linestring(\\sz)?)/i)) return null;\n    white();\n    if (!$(/^(\\()/)) return null;\n    var c = coords();\n    if (!c) return null;\n    if (!$(/^(\\))/)) return null;\n    return {\n      type: 'LineString',\n      coordinates: c\n    };\n  }\n\n  function polygon() {\n    if (!$(/^(polygon(\\sz)?)/i)) return null;\n    white();\n    var c = multicoords();\n    if (!c) return null;\n    return {\n      type: 'Polygon',\n      coordinates: c\n    };\n  }\n\n  function multipolygon() {\n    if (!$(/^(multipolygon)/i)) return null;\n    white();\n    var c = multicoords();\n    if (!c) return null;\n    return {\n      type: 'MultiPolygon',\n      coordinates: c\n    };\n  }\n\n  function geometrycollection() {\n    var geometries = [];\n    var geometry;\n    if (!$(/^(geometrycollection)/i)) return null;\n    white();\n    if (!$(/^(\\()/)) return null;\n\n    while (geometry = root()) {\n      geometries.push(geometry);\n      white();\n      $(/^(,)/);\n      white();\n    }\n\n    if (!$(/^(\\))/)) return null;\n    return {\n      type: 'GeometryCollection',\n      geometries: geometries\n    };\n  }\n\n  function root() {\n    return point() || linestring() || polygon() || multipoint() || multilinestring() || multipolygon() || geometrycollection();\n  }\n\n  return crs(root());\n}\n/**\n * Stringifies a GeoJSON object into WKT\n */\n\n\nfunction stringify(gj) {\n  if (gj.type === 'Feature') {\n    gj = gj.geometry;\n  }\n\n  function pairWKT(c) {\n    return c.join(' ');\n  }\n\n  function ringWKT(r) {\n    return r.map(pairWKT).join(', ');\n  }\n\n  function ringsWKT(r) {\n    return r.map(ringWKT).map(wrapParens).join(', ');\n  }\n\n  function multiRingsWKT(r) {\n    return r.map(ringsWKT).map(wrapParens).join(', ');\n  }\n\n  function wrapParens(s) {\n    return '(' + s + ')';\n  }\n\n  switch (gj.type) {\n    case 'Point':\n      return 'POINT (' + pairWKT(gj.coordinates) + ')';\n\n    case 'LineString':\n      return 'LINESTRING (' + ringWKT(gj.coordinates) + ')';\n\n    case 'Polygon':\n      return 'POLYGON (' + ringsWKT(gj.coordinates) + ')';\n\n    case 'MultiPoint':\n      return 'MULTIPOINT (' + ringWKT(gj.coordinates) + ')';\n\n    case 'MultiPolygon':\n      return 'MULTIPOLYGON (' + multiRingsWKT(gj.coordinates) + ')';\n\n    case 'MultiLineString':\n      return 'MULTILINESTRING (' + ringsWKT(gj.coordinates) + ')';\n\n    case 'GeometryCollection':\n      return 'GEOMETRYCOLLECTION (' + gj.geometries.map(stringify).join(', ') + ')';\n\n    default:\n      throw new Error('stringify requires a valid GeoJSON Feature or geometry object as input');\n  }\n}","map":{"version":3,"sources":["C:/Users/simfug/node_modules/wellknown/index.js"],"names":["module","exports","parse","stringify","numberRegexp","tuples","RegExp","source","input","parts","split","_","pop","srid","shift","i","$","re","match","substring","length","crs","obj","type","properties","name","white","multicoords","depth","rings","stack","pointer","elem","push","some","isNaN","Array","prototype","apply","map","parseFloat","coords","list","item","pt","point","c","coordinates","multipoint","newCoordsFormat","indexOf","replace","multilinestring","linestring","polygon","multipolygon","geometrycollection","geometries","geometry","root","gj","pairWKT","join","ringWKT","r","ringsWKT","wrapParens","multiRingsWKT","s","Error"],"mappings":"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","sourcesContent":["/*eslint-disable no-cond-assign */\nmodule.exports = parse;\nmodule.exports.parse = parse;\nmodule.exports.stringify = stringify;\n\nvar numberRegexp = /[-+]?([0-9]*\\.[0-9]+|[0-9]+)([eE][-+]?[0-9]+)?/;\n// Matches sequences like '100 100' or '100 100 100'.\nvar tuples = new RegExp('^' + numberRegexp.source + '(\\\\s' + numberRegexp.source + '){1,}');\n\n/*\n * Parse WKT and return GeoJSON.\n *\n * @param {string} _ A WKT geometry\n * @return {?Object} A GeoJSON geometry object\n */\nfunction parse (input) {\n  var parts = input.split(';');\n  var _ = parts.pop();\n  var srid = (parts.shift() || '').split('=').pop();\n\n  var i = 0;\n\n  function $ (re) {\n    var match = _.substring(i).match(re);\n    if (!match) return null;\n    else {\n      i += match[0].length;\n      return match[0];\n    }\n  }\n\n  function crs (obj) {\n    if (obj && srid.match(/\\d+/)) {\n      obj.crs = {\n        type: 'name',\n        properties: {\n          name: 'urn:ogc:def:crs:EPSG::' + srid\n        }\n      };\n    }\n\n    return obj;\n  }\n\n  function white () { $(/^\\s*/); }\n\n  function multicoords () {\n    white();\n    var depth = 0;\n    var rings = [];\n    var stack = [rings];\n    var pointer = rings;\n    var elem;\n\n    while (elem =\n           $(/^(\\()/) ||\n             $(/^(\\))/) ||\n               $(/^(,)/) ||\n                 $(tuples)) {\n      if (elem === '(') {\n        stack.push(pointer);\n        pointer = [];\n        stack[stack.length - 1].push(pointer);\n        depth++;\n      } else if (elem === ')') {\n        // For the case: Polygon(), ...\n        if (pointer.length === 0) return null;\n\n        pointer = stack.pop();\n        // the stack was empty, input was malformed\n        if (!pointer) return null;\n        depth--;\n        if (depth === 0) break;\n      } else if (elem === ',') {\n        pointer = [];\n        stack[stack.length - 1].push(pointer);\n      } else if (!elem.split(/\\s/g).some(isNaN)) {\n        Array.prototype.push.apply(pointer, elem.split(/\\s/g).map(parseFloat));\n      } else {\n        return null;\n      }\n      white();\n    }\n\n    if (depth !== 0) return null;\n\n    return rings;\n  }\n\n  function coords () {\n    var list = [];\n    var item;\n    var pt;\n    while (pt =\n           $(tuples) ||\n             $(/^(,)/)) {\n      if (pt === ',') {\n        list.push(item);\n        item = [];\n      } else if (!pt.split(/\\s/g).some(isNaN)) {\n        if (!item) item = [];\n        Array.prototype.push.apply(item, pt.split(/\\s/g).map(parseFloat));\n      }\n      white();\n    }\n\n    if (item) list.push(item);\n    else return null;\n\n    return list.length ? list : null;\n  }\n\n  function point () {\n    if (!$(/^(point(\\sz)?)/i)) return null;\n    white();\n    if (!$(/^(\\()/)) return null;\n    var c = coords();\n    if (!c) return null;\n    white();\n    if (!$(/^(\\))/)) return null;\n    return {\n      type: 'Point',\n      coordinates: c[0]\n    };\n  }\n\n  function multipoint () {\n    if (!$(/^(multipoint)/i)) return null;\n    white();\n    var newCoordsFormat = _\n      .substring(_.indexOf('(') + 1, _.length - 1)\n      .replace(/\\(/g, '')\n      .replace(/\\)/g, '');\n    _ = 'MULTIPOINT (' + newCoordsFormat + ')';\n    var c = multicoords();\n    if (!c) return null;\n    white();\n    return {\n      type: 'MultiPoint',\n      coordinates: c\n    };\n  }\n\n  function multilinestring () {\n    if (!$(/^(multilinestring)/i)) return null;\n    white();\n    var c = multicoords();\n    if (!c) return null;\n    white();\n    return {\n      type: 'MultiLineString',\n      coordinates: c\n    };\n  }\n\n  function linestring () {\n    if (!$(/^(linestring(\\sz)?)/i)) return null;\n    white();\n    if (!$(/^(\\()/)) return null;\n    var c = coords();\n    if (!c) return null;\n    if (!$(/^(\\))/)) return null;\n    return {\n      type: 'LineString',\n      coordinates: c\n    };\n  }\n\n  function polygon () {\n    if (!$(/^(polygon(\\sz)?)/i)) return null;\n    white();\n    var c = multicoords();\n    if (!c) return null;\n    return {\n      type: 'Polygon',\n      coordinates: c\n    };\n  }\n\n  function multipolygon () {\n    if (!$(/^(multipolygon)/i)) return null;\n    white();\n    var c = multicoords();\n    if (!c) return null;\n    return {\n      type: 'MultiPolygon',\n      coordinates: c\n    };\n  }\n\n  function geometrycollection () {\n    var geometries = [];\n    var geometry;\n\n    if (!$(/^(geometrycollection)/i)) return null;\n    white();\n\n    if (!$(/^(\\()/)) return null;\n    while (geometry = root()) {\n      geometries.push(geometry);\n      white();\n      $(/^(,)/);\n      white();\n    }\n    if (!$(/^(\\))/)) return null;\n\n    return {\n      type: 'GeometryCollection',\n      geometries: geometries\n    };\n  }\n\n  function root () {\n    return point() ||\n      linestring() ||\n      polygon() ||\n      multipoint() ||\n      multilinestring() ||\n      multipolygon() ||\n      geometrycollection();\n  }\n\n  return crs(root());\n}\n\n/**\n * Stringifies a GeoJSON object into WKT\n */\nfunction stringify (gj) {\n  if (gj.type === 'Feature') {\n    gj = gj.geometry;\n  }\n\n  function pairWKT (c) {\n    return c.join(' ');\n  }\n\n  function ringWKT (r) {\n    return r.map(pairWKT).join(', ');\n  }\n\n  function ringsWKT (r) {\n    return r.map(ringWKT).map(wrapParens).join(', ');\n  }\n\n  function multiRingsWKT (r) {\n    return r.map(ringsWKT).map(wrapParens).join(', ');\n  }\n\n  function wrapParens (s) { return '(' + s + ')'; }\n\n  switch (gj.type) {\n    case 'Point':\n      return 'POINT (' + pairWKT(gj.coordinates) + ')';\n    case 'LineString':\n      return 'LINESTRING (' + ringWKT(gj.coordinates) + ')';\n    case 'Polygon':\n      return 'POLYGON (' + ringsWKT(gj.coordinates) + ')';\n    case 'MultiPoint':\n      return 'MULTIPOINT (' + ringWKT(gj.coordinates) + ')';\n    case 'MultiPolygon':\n      return 'MULTIPOLYGON (' + multiRingsWKT(gj.coordinates) + ')';\n    case 'MultiLineString':\n      return 'MULTILINESTRING (' + ringsWKT(gj.coordinates) + ')';\n    case 'GeometryCollection':\n      return 'GEOMETRYCOLLECTION (' + gj.geometries.map(stringify).join(', ') + ')';\n    default:\n      throw new Error('stringify requires a valid GeoJSON Feature or geometry object as input');\n  }\n}\n"]},"metadata":{},"sourceType":"script"}